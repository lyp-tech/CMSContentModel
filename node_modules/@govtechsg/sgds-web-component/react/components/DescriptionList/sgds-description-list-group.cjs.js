'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var lit = require('lit');
var decorators_js = require('lit/decorators.js');
var sgdsElement = require('../../base/sgds-element.cjs.js');
var descriptionListGroup = require('./description-list-group.cjs.js');
var slot = require('../../utils/slot.cjs.js');

/**
 * @summary Description List Group organizes multiple description lists.
 *
 * @slot default - The slot for `description-list` components
 * @slot title - Slot for the title content
 * @slot description - Slot for the description content
 *
 */
class SgdsDescriptionListGroup extends sgdsElement["default"] {
    constructor() {
        super(...arguments);
        /** When true, adds a border around the entire group. */
        this.bordered = false;
        /** When true, the description lists are displayed in a stacked layout. */
        this.stacked = false;
        /** @internal */
        this.hasSlotController = new slot.HasSlotController(this, "title", "description");
    }
    connectedCallback() {
        super.connectedCallback();
        this.setAttribute("role", "list");
        this.updateComplete.then(() => {
            this._updateDescriptionLists();
        });
    }
    _updateDescriptionLists() {
        if (!this._descriptionLists)
            return;
        this._descriptionLists.forEach((descriptionList, index) => {
            if (this.stacked) {
                descriptionList.setAttribute("stacked", "");
            }
            else {
                descriptionList.removeAttribute("stacked");
            }
            if (this.bordered) {
                descriptionList.setAttribute("bordered", "");
            }
            else {
                descriptionList.removeAttribute("bordered");
            }
            if (index === this._descriptionLists.length - 1) {
                descriptionList.setAttribute("isLastChild", "");
            }
        });
    }
    updated(_changedProperties) {
        if (_changedProperties.has("stacked")) {
            this._updateDescriptionLists();
        }
        if (_changedProperties.has("bordered")) {
            this._updateDescriptionLists();
        }
    }
    render() {
        const hasTitleSlot = this.hasSlotController.test("title");
        const hasDescriptionSlot = this.hasSlotController.test("description");
        return lit.html `
      <div class="container" part="base">
        ${hasTitleSlot || hasDescriptionSlot
            ? lit.html `
              <div class="header">
                ${hasTitleSlot
                ? lit.html ` <div class="title">
                      <slot name="title"></slot>
                    </div>`
                : lit.nothing}
                ${hasDescriptionSlot
                ? lit.html `
                      <div class="description">
                        <slot name="description"></slot>
                      </div>
                    `
                : lit.nothing}
              </div>
            `
            : lit.nothing}
        <div>
          <slot></slot>
        </div>
      </div>
    `;
    }
}
SgdsDescriptionListGroup.styles = [...sgdsElement["default"].styles, descriptionListGroup["default"]];
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsDescriptionListGroup.prototype, "bordered", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsDescriptionListGroup.prototype, "stacked", void 0);
tslib.__decorate([
    decorators_js.queryAssignedElements({ flatten: true })
], SgdsDescriptionListGroup.prototype, "_descriptionLists", void 0);

exports.SgdsDescriptionListGroup = SgdsDescriptionListGroup;
exports["default"] = SgdsDescriptionListGroup;
//# sourceMappingURL=sgds-description-list-group.cjs.js.map

import { __decorate } from 'tslib';
import { isEqual, isBefore } from 'date-fns';
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import SgdsElement from '../../base/sgds-element.js';
import { sanitizedPreviousMonth, sanitizedNextMonth } from '../../utils/time.js';
import { watch } from '../../utils/watch.js';
import { SgdsButton } from '../Button/sgds-button.js';
import { SgdsIconButton } from '../IconButton/sgds-icon-button.js';
import css_248z from './datepicker-header2.js';
import { SgdsIcon } from '../Icon/sgds-icon.js';

class DatepickerHeader extends SgdsElement {
    constructor() {
        super(...arguments);
        /** @internal */
        this.selectedDate = [];
    }
    _handleFocusedTabIndexChange() {
        let buttonToFocus;
        switch (this.focusedTabIndex) {
            case 0:
                buttonToFocus = this.shadowRoot.querySelector("sgds-icon-button[name='arrow-left']");
                break;
            case 1:
                buttonToFocus = this.shadowRoot.querySelector("sgds-button");
                break;
            case 2:
                buttonToFocus = this.shadowRoot.querySelector("sgds-icon-button[name='arrow-right']");
                break;
            default:
                return;
        }
        buttonToFocus.focus();
    }
    _changeView() {
        switch (this.view) {
            case "days":
                this.view = "months";
                break;
            case "months":
                this.view = "years";
                break;
        }
        this.emit("sgds-view", { detail: this.view }); // emit event to render the correct view
    }
    renderHeader(displayDate = this.displayDate, view = this.view) {
        if (view === "months") {
            return displayDate.getFullYear();
        }
        if (view === "years") {
            const CURRENT_YEAR = new Date().getFullYear();
            const displayYear = displayDate.getFullYear();
            const remainder = (displayYear - CURRENT_YEAR) % 12;
            const yearsPosition = remainder < 0 ? 12 + remainder : remainder;
            const startLimit = displayYear - yearsPosition;
            const endLimit = displayYear - yearsPosition + 12 - 1;
            return `${startLimit} - ${endLimit}`;
        }
        return `${MONTH_LABELS[displayDate.getMonth()]} ${displayDate.getFullYear()}`;
    }
    _renderHeaderTemplate() {
        return html `${this.renderHeader()}`;
    }
    /** @internal */
    handleClickPrevious() {
        const { view, displayDate, focusedDate } = this;
        let newDisplayDate = new Date(displayDate);
        if (view === "months") {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 1);
        }
        else if (this.view === "years") {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() - 12);
        }
        else {
            /**
             * FocusedDate gets precedence over displayDate.
             *  This happens when the arrow keys are pressed to
             *  change focus date and user clicks the arrow buttons to
             * shift months
             */
            if (focusedDate.getDate() !== displayDate.getDate()) {
                newDisplayDate = sanitizedPreviousMonth(focusedDate);
            }
            else {
                newDisplayDate = sanitizedPreviousMonth(newDisplayDate);
            }
        }
        this.displayDate = newDisplayDate; // Update the displayDate property
        // emit event to render correct view
        this.emit("sgds-change-calendar", { detail: this.displayDate });
    }
    /** @internal */
    _handleClickNext() {
        const { view, displayDate, focusedDate } = this;
        let newDisplayDate = new Date(displayDate);
        if (view === "months") {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 1);
        }
        else if (this.view === "years") {
            newDisplayDate.setFullYear(newDisplayDate.getFullYear() + 12);
        }
        else {
            /** FocusedDate gets precedence over displayDate  */
            if (focusedDate.getDate() !== displayDate.getDate()) {
                newDisplayDate = sanitizedNextMonth(focusedDate);
            }
            else {
                newDisplayDate = sanitizedNextMonth(newDisplayDate);
            }
        }
        this.displayDate = newDisplayDate; // Update the displayDate property
        //emit event to render correct view
        this.emit("sgds-change-calendar", { detail: this.displayDate });
    }
    _removeCaret() {
        const displayYear = this.displayDate.getFullYear();
        const displayMonth = this.displayDate.getMonth();
        const displayMonthYear = new Date(displayYear, displayMonth);
        if (this.view === "months") {
            return displayYear <= 1900;
        }
        if (this.view === "years") {
            return displayYear < 1904;
        }
        return isEqual(displayMonthYear, new Date(0, 0, 1)) || isBefore(displayMonthYear, new Date(0, 0, 1));
    }
    _ariaLabelForNextBtn() {
        const nextBtnDate = {
            days: "Show next month",
            months: "Show next year",
            years: "Show next 12 years"
        };
        return nextBtnDate[this.view];
    }
    _ariaLabelForPrevBtn() {
        const prevBtnDate = {
            days: "Show previous month",
            months: "Show previous year",
            years: "Show previous 12 years"
        };
        return prevBtnDate[this.view];
    }
    _ariaLabelForHeaderBtn() {
        const message = {
            days: `Current view is days, click to show months in ${this.displayDate.getFullYear()}`,
            months: `Current view is months, click to show years between ${this.renderHeader(this.displayDate, "years")}`,
            years: `Current view is years`
        };
        return `${this.renderHeader()}. ${message[this.view]}`;
    }
    render() {
        return html `
      <div class="datepicker-header dropdown-header" role="heading">
        <sgds-icon-button
          name="arrow-left"
          size="sm"
          variant="ghost"
          @click="${this.handleClickPrevious}"
          class=${classMap({ invisible: this._removeCaret() })}
          aria-label=${this._ariaLabelForPrevBtn()}
        >
        </sgds-icon-button>
        <sgds-button
          fullWidth
          variant="ghost"
          size="sm"
          @click=${this._changeView}
          class=${classMap({ disabled: this.view === "years" })}
          aria-disabled=${this.view === "years" ? "true" : "false"}
          aria-live="polite"
        >
          ${this._renderHeaderTemplate()}
        </sgds-button>
        <sgds-icon-button
          name="arrow-right"
          size="sm"
          variant="ghost"
          @click="${this._handleClickNext}"
          aria-label=${this._ariaLabelForNextBtn()}
        >
        </sgds-icon-button>
      </div>
    `;
    }
}
DatepickerHeader.styles = [css_248z];
/** @internal */
DatepickerHeader.dependencies = {
    "sgds-icon": SgdsIcon,
    "sgds-icon-button": SgdsIconButton,
    "sgds-button": SgdsButton
};
__decorate([
    property({ attribute: false })
], DatepickerHeader.prototype, "displayDate", void 0);
__decorate([
    property({ attribute: false })
], DatepickerHeader.prototype, "focusedDate", void 0);
__decorate([
    property({ attribute: false })
], DatepickerHeader.prototype, "selectedDate", void 0);
__decorate([
    property()
], DatepickerHeader.prototype, "view", void 0);
__decorate([
    property()
], DatepickerHeader.prototype, "focusedTabIndex", void 0);
__decorate([
    watch("focusedTabIndex", { waitUntilFirstUpdate: true })
], DatepickerHeader.prototype, "_handleFocusedTabIndexChange", null);
const MONTH_LABELS = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];

export { DatepickerHeader, MONTH_LABELS, DatepickerHeader as default };
//# sourceMappingURL=datepicker-header.js.map

'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var lit = require('lit');
var context = require('@lit/context');
var decorators_js = require('lit/decorators.js');
var classMap_js = require('lit/directives/class-map.js');
var sgdsElement = require('../../base/sgds-element.cjs.js');
var animate = require('../../utils/animate.cjs.js');
var animationRegistry = require('../../utils/animation-registry.cjs.js');
var breakpoints = require('../../utils/breakpoints.cjs.js');
var event = require('../../utils/event.cjs.js');
var generateId = require('../../utils/generateId.cjs.js');
var watch = require('../../utils/watch.cjs.js');
var mainnav = require('./mainnav.cjs.js');
var sgdsIcon = require('../Icon/sgds-icon.cjs.js');
var mainnavContext = require('./mainnav-context.cjs.js');

const SIZES = {
    sm: breakpoints.SM_BREAKPOINT,
    md: breakpoints.MD_BREAKPOINT,
    lg: breakpoints.LG_BREAKPOINT,
    xl: breakpoints.XL_BREAKPOINT,
    XXL: breakpoints.XXL_BREAKPOINT,
    never: Infinity,
    always: -1
};
/**
 * @summary This component is the primary means that your users will use to navigate through your portal. It includes horizontal navigation and branding to identify your site.
 *
 * @event sgds-show - Emitted on show. Only for collapsed menu.
 * @event sgds-after-show - Emitted on show after animation has completed. Only for collapsed menu.
 * @event sgds-hide - Emitted on hide. Only for collapsed menu.
 * @event sgds-after-hide - Emitted on hide after animation has completed. Only for collapsed menu.
 *
 * @slot default - Default slot of SgdsMainnav. Pass in SgdsMainnavItem elements here.
 * @slot end - Elements in this slot will be positioned to the right end of .navbar-nav. Elements in this slot will also be included in collapsed menu.
 * @slot brand - Brand slot of SgdsMainnav. Pass in brand logo img here
 * @slot non-collapsible - Elements in this slot will not be collapsed
 *
 */
class SgdsMainnav extends sgdsElement["default"] {
    constructor() {
        super();
        this._breakpointReached = false;
        /** The href link for brand logo */
        this.brandHref = "";
        this.collapseId = generateId["default"]("mainnav", "collapse");
        /** The breakpoint, below which, the Navbar will collapse. When always the Navbar will always be expanded regardless of screen size. When never, the Navbar will always be collapsed */
        this.expand = "lg";
        /** @internal */
        this.breakpointReached = false;
        /** @internal */
        this.expanded = false;
        window.addEventListener("resize", () => {
            const newBreakpointReachedValue = window.innerWidth < SIZES[this.expand];
            if (newBreakpointReachedValue !== this.breakpointReached) {
                this.requestUpdate();
            }
            else {
                this.body ? (this.body.hidden = true) : null;
                this.expanded = false;
            }
            if (newBreakpointReachedValue) {
                this._handleMobileNav();
                if (!this._breakpointReached) {
                    this._breakpointReached = true;
                }
            }
            else {
                this._handleDesktopNav();
                this._breakpointReached = false;
            }
        });
    }
    /** @internal */
    get defaultSlotItems() {
        return [...(this.defaultNodes || [])].filter((node) => typeof node.tagName !== "undefined");
    }
    /** @internal */
    get endSlotItems() {
        return [...(this.endNodes || [])].filter((node) => typeof node.tagName !== "undefined");
    }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener("click", (event) => this._handleClickOutOfElement(event, this.body));
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("click", (event) => this._handleClickOutOfElement(event, this.body));
    }
    firstUpdated() {
        if (this.breakpointReached && this.body) {
            this.expanded = false;
            this.body.hidden = true;
            this._handleMobileNav();
            this._breakpointReached = true;
        }
        const items = [...this.defaultSlotItems, ...this.endSlotItems];
        items.forEach((item) => {
            item.setAttribute("expand", this.expand);
        });
    }
    _handleClickOutOfElement(e, self) {
        if (!e.composedPath().includes(self) && !e.composedPath().includes(this.header)) {
            this.hide();
        }
    }
    _handleSummaryClick() {
        if (this.expanded) {
            this.hide();
        }
        else {
            document.querySelector("body").style.overflow = "hidden";
            this.show();
        }
        this.header.focus();
    }
    async _handleMobileNav() {
        if (!this.nav)
            return;
        this.nav.appendChild(this.body);
        await customElements.whenDefined("sgds-masthead");
        const offsetTop = this.nav.offsetTop;
        const navHeight = this.nav.clientHeight;
        const mainNavPosition = offsetTop + navHeight;
        this.body.style.top = `${mainNavPosition}px`;
        this.navScroll.style.maxHeight = `calc(100dvh - ${mainNavPosition}px)`;
    }
    _handleDesktopNav() {
        var _a;
        (_a = this.navbar) === null || _a === void 0 ? void 0 : _a.insertBefore(this.body, this.nonCollapsibleSlot);
    }
    async _animateToShow() {
        const sgdsShow = this.emit("sgds-show", { cancelable: true });
        if (sgdsShow.defaultPrevented) {
            this.expanded = false;
            return;
        }
        await animate.stopAnimations(this.body);
        this.body.hidden = false;
        const { keyframes, options } = animationRegistry.getAnimation(this, "mainnav.show");
        await animate.animateTo(this.body, animate.shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
        this.body.style.height = "auto";
        this.emit("sgds-after-show");
    }
    async _animateToHide() {
        const slHide = this.emit("sgds-hide", { cancelable: true });
        if (slHide.defaultPrevented) {
            this.expanded = true;
            return;
        }
        await animate.stopAnimations(this.body);
        const { keyframes, options } = animationRegistry.getAnimation(this, "mainnav.hide");
        await animate.animateTo(this.body, animate.shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
        this.body.hidden = true;
        this.body.style.height = "auto";
        this.emit("sgds-after-hide");
    }
    async handleOpenChange() {
        if (this.expanded) {
            // Show
            this._animateToShow();
        }
        else {
            // Hide
            this._animateToHide();
        }
    }
    /** Shows the menu. For when mainnav is in the collapsed form */
    async show() {
        if (this.expanded) {
            return;
        }
        this.expanded = true;
        return event.waitForEvent(this, "sgds-after-show");
    }
    /** Hide the menu. For when mainnav is in the collapsed form */
    async hide() {
        if (!this.expanded) {
            return;
        }
        this.expanded = false;
        document.querySelector("body").style.removeProperty("overflow");
        this.emit("close-dropdown-menu");
        return event.waitForEvent(this, "sgds-after-hide");
    }
    // assigning name attribute to elements added in slot="end", to use wildcard css selector to assign styles only to *-mainnav-item
    _handleSlotChange(e) {
        const childElements = e.target.assignedElements({ flatten: true });
        childElements.forEach(e => {
            e.setAttribute("name", e.tagName.toLowerCase());
        });
    }
    render() {
        this.breakpointReached = window.innerWidth < SIZES[this.expand];
        return lit.html `
      <nav>
        <div class="navbar ${this._expandClass()}">
          <a class="navbar-brand" href=${this.brandHref} aria-label="brand-link">
            <slot name="brand"></slot>
          </a>
          <div class="navbar-body navbar-collapse" id=${this.collapseId}>
            <div class="navbar-nav navbar-nav-scroll">
              <slot></slot>
              <slot
                name="end"
                class=${classMap_js.classMap({ "slot-end": !this.breakpointReached })}
                @slotchange=${this._handleSlotChange}
              ></slot>
            </div>
          </div>
          <slot name="non-collapsible"></slot>
          <sgds-icon-button
            name=${this.expanded ? "cross" : "menu"}
            variant="ghost"
            size="sm"
            class="navbar-toggler"
            @click=${this._handleSummaryClick}
            aria-controls="${this.collapseId}"
            aria-expanded="${this.expanded}"
            aria-label="Toggle navigation"
          ></sgds-icon-button>
        </div>
      </nav>
    `;
    }
    _expandClass() {
        switch (this.expand) {
            case "always":
                return "navbar-expand";
            case "never":
                break;
            default:
                return `navbar-expand-${this.expand}`;
        }
    }
}
SgdsMainnav.styles = [...sgdsElement["default"].styles, mainnav["default"]];
/** @internal */
SgdsMainnav.dependencies = {
    "sgds-icon": sgdsIcon.SgdsIcon
};
tslib.__decorate([
    context.provide({ context: mainnavContext.MainnavContext }),
    decorators_js.state()
], SgdsMainnav.prototype, "_breakpointReached", void 0);
tslib.__decorate([
    decorators_js.query("nav")
], SgdsMainnav.prototype, "nav", void 0);
tslib.__decorate([
    decorators_js.query(".navbar")
], SgdsMainnav.prototype, "navbar", void 0);
tslib.__decorate([
    decorators_js.query(".navbar-toggler")
], SgdsMainnav.prototype, "header", void 0);
tslib.__decorate([
    decorators_js.query(".navbar-body")
], SgdsMainnav.prototype, "body", void 0);
tslib.__decorate([
    decorators_js.query(".navbar-nav-scroll")
], SgdsMainnav.prototype, "navScroll", void 0);
tslib.__decorate([
    decorators_js.query("slot[name='non-collapsible']")
], SgdsMainnav.prototype, "nonCollapsibleSlot", void 0);
tslib.__decorate([
    decorators_js.property({ type: String })
], SgdsMainnav.prototype, "brandHref", void 0);
tslib.__decorate([
    decorators_js.property({ type: String })
], SgdsMainnav.prototype, "expand", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsMainnav.prototype, "breakpointReached", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsMainnav.prototype, "expanded", void 0);
tslib.__decorate([
    decorators_js.queryAssignedElements()
], SgdsMainnav.prototype, "defaultNodes", void 0);
tslib.__decorate([
    decorators_js.queryAssignedElements({ slot: "end" })
], SgdsMainnav.prototype, "endNodes", void 0);
tslib.__decorate([
    watch.watch("expanded", { waitUntilFirstUpdate: true })
], SgdsMainnav.prototype, "handleOpenChange", null);
animationRegistry.setDefaultAnimation("mainnav.show", {
    keyframes: [
        { height: "0", opacity: "0" },
        { height: "auto", opacity: "1" }
    ],
    options: { duration: 200, easing: "ease-in-out" }
});
animationRegistry.setDefaultAnimation("mainnav.hide", {
    keyframes: [
        { height: "auto", opacity: "1" },
        { height: "0", opacity: "0" }
    ],
    options: { duration: 200, easing: "ease-in-out" }
});

exports.SgdsMainnav = SgdsMainnav;
exports["default"] = SgdsMainnav;
//# sourceMappingURL=sgds-mainnav.cjs.js.map

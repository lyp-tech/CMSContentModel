import { __decorate } from 'tslib';
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import FormControlElement from '../../base/form-control-element.js';
import { defaultValue } from '../../utils/defaultvalue.js';
import { SgdsFormValidatorMixin } from '../../utils/validatorMixin.js';
import { watch } from '../../utils/watch.js';
import css_248z from './checkbox.js';

/**
 * @summary Checkbox component is used when you require users to select multiple items from a list.
 *
 * @slot default - The label of checkbox.
 *
 * @event sgds-change - Emitted when the checked state changes.
 * @event sgds-blur - Emitted when input is not in focus.
 * @event sgds-focus - Emitted when input is in focus.
 * @event sgds-validity-change - Emitted when the invalid state changes. This event is used by sgds-checkbox-group to check the invalid state change of its children
 */
class SgdsCheckbox extends SgdsFormValidatorMixin(FormControlElement) {
    constructor() {
        super(...arguments);
        /** Draws the checkbox in a checked state. */
        this.checked = false;
        /** Allows invalidFeedback, invalid and valid styles to be visible with the input */
        this.hasFeedback = false;
        /** Gets or sets the default value used to reset this element. The initial value corresponds to the one originally specified in the HTML that created this element. */
        this.defaultChecked = false;
        /** Marks the checkbox input as indeterminate , with indeterminate logo  */
        this.indeterminate = false;
        /** Makes the checkbox a required field. */
        this.required = false;
        this._isTouched = false;
    }
    _handleInvalidChange() {
        this.emit("sgds-validity-change", {
            detail: { invalid: this.invalid, validationMessage: this.input.validationMessage }
        });
    }
    /** Simulates a click on the checkbox. */
    click() {
        this.input.click();
    }
    /** Sets focus on the checkbox. */
    focus(options) {
        this.input.focus(options);
    }
    /** Removes focus from the checkbox. */
    blur() {
        this.input.blur();
    }
    _handleChange(e) {
        if (this.indeterminate) {
            this.indeterminate = !this.indeterminate;
        }
        this.checked = !this.checked;
        this.value = this.input.value;
        super._mixinHandleChange(e);
        this.emit("sgds-change", { detail: { checked: this.checked, value: this.value } });
    }
    _handleKeyDown(event) {
        const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
        if (event.key === "Enter" && !hasModifier) {
            this.click();
        }
    }
    _handleBlur() {
        this._isTouched = true;
        this.emit("sgds-blur");
    }
    _handleFocus() {
        this.emit("sgds-focus");
    }
    _handleInvalid(e) {
        e.preventDefault();
        this.invalid = true;
    }
    /** @internal */
    _handleDisabledChange() {
        // Disabled form controls are always valid, so we need to recheck validity when the state changes
        this.setInvalid(false);
    }
    _handleIsTouched() {
        if (this._isTouched) {
            this.invalid = !this.input.checkValidity();
        }
    }
    _mixinResetFormControl() {
        this._isTouched = false;
        this.checked = this.input.checked = this.defaultChecked;
        this.input.dispatchEvent(new InputEvent("reset"));
        this._mixinResetValidity(this.input);
    }
    /**
     * Checks for validity. Under the hood, HTMLFormElement's reportValidity method calls this method to check for component's validity state
     * Note that the native error popup is prevented for SGDS form components by default. Instead the validation message shows up in the feedback container of SgdsInput
     */
    reportValidity() {
        return this._mixinReportValidity();
    }
    /**
     * Checks for validity without any native error popup message
     */
    checkValidity() {
        return this._mixinCheckValidity();
    }
    /**
     * Returns the ValidityState object
     */
    get validity() {
        return this._mixinGetValidity();
    }
    /**
     * Returns the validation message based on the ValidityState
     */
    get validationMessage() {
        return this._mixinGetValidationMessage();
    }
    render() {
        return html `
      <div class="form-check">
        <div class="form-check-input-container">
          <input
            class=${classMap({
            "form-check-input": true,
            "is-invalid": this.hasFeedback && this.invalid
        })}
            type="checkbox"
            id=${this._controlId}
            aria-invalid=${this.invalid ? "true" : "false"}
            name=${ifDefined(this.name)}
            ?indeterminate=${this.indeterminate}
            ?required=${this.required}
            aria-disabled=${this.disabled ? "true" : "false"}
            aria-checked=${this.checked ? "true" : "false"}
            @change=${(e) => this._handleChange(e)}
            @keydown=${this._handleKeyDown}
            @invalid=${(e) => this._handleInvalid(e)}
            .checked=${live(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            @blur=${this._handleBlur}
            @focus=${this._handleFocus}
          />
        </div>
        <label for="${this._controlId}" class="form-check-label" id="${this._labelId}"><slot></slot></label>
      </div>
    `;
    }
}
SgdsCheckbox.styles = [...FormControlElement.styles, css_248z];
__decorate([
    property({ type: String, reflect: true })
], SgdsCheckbox.prototype, "value", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "checked", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "hasFeedback", void 0);
__decorate([
    defaultValue("checked")
], SgdsCheckbox.prototype, "defaultChecked", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "indeterminate", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "required", void 0);
__decorate([
    state()
], SgdsCheckbox.prototype, "_isTouched", void 0);
__decorate([
    watch("invalid", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleInvalidChange", null);
__decorate([
    watch("disabled", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleDisabledChange", null);
__decorate([
    watch("_isTouched", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleIsTouched", null);

export { SgdsCheckbox, SgdsCheckbox as default };
//# sourceMappingURL=sgds-checkbox.js.map

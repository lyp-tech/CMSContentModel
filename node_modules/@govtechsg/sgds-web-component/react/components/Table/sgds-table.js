'use client';
import { __decorate } from 'tslib';
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import SgdsElement from '../../base/sgds-element.js';
import css_248z from './table.js';

/**
 * @summary The use of a table is to organise a collections of data into readable rows
 */
class SgdsTable extends SgdsElement {
    constructor() {
        super(...arguments);
        /**
         * Populate row header cells using Arrays
         */
        this.rowHeader = [];
        /**
         * Populate column header cells using Arrays only when <code>headerPosition="vertical"</code> or <code>headerPosition="both"</code>
         */
        this.columnHeader = [];
        /**
         * Populate data cells using Arrays
         */
        this.tableData = [];
        /**
         * Defines the placement of headers in the table (horizontal, vertical, or both)
         */
        this.headerPosition = "horizontal";
        /** @internal */
        this.originalTableData = [];
    }
    connectedCallback() {
        super.connectedCallback();
        this.originalTableData = [...this.tableData];
    }
    _renderTable() {
        if (this.headerPosition === "horizontal") {
            return html `
        <thead>
          <tr>
            ${this.rowHeader.map((header, index) => html ` <th>${header}</th> `)}
          </tr>
        </thead>
        <tbody>
          ${this.tableData.map(row => html `
              <tr>
                ${row.map((cell) => html `<td>${cell}</td>`)}
              </tr>
            `)}
        </tbody>
      `;
        }
        if (this.headerPosition === "both") {
            return html `
        <thead>
          <tr>
            <th></th>
            ${this.rowHeader.map((header, index) => html ` <th>${header}</th> `)}
          </tr>
        </thead>
        <tbody>
          ${this.tableData.map((row, index) => html `
              <tr>
                <th>${this.columnHeader[index]}</th>
                ${row.map((cell) => html `<td>${cell}</td>`)}
              </tr>
            `)}
        </tbody>
      `;
        }
        if (this.headerPosition === "vertical") {
            const flippedTableData = this.tableData[0].map((_, colIndex) => this.tableData.map(row => row[colIndex]));
            return html `
        ${flippedTableData.map((row, index) => html `
            <tr>
              <th>${this.columnHeader[index]}</th>
              ${row.map((cell) => html `<td>${cell}</td>`)}
            </tr>
          `)}
      `;
        }
    }
    render() {
        return html `
      <div
        class=${classMap({
            "table-responsive": this.responsive === "always",
            "table-responsive-sm": this.responsive === "sm",
            "table-responsive-md": this.responsive === "md",
            "table-responsive-lg": this.responsive === "lg",
            "table-responsive-xl": this.responsive === "xl"
        })}
        tabindex="0"
      >
        <table class="table">
          ${this._renderTable()}
        </table>
      </div>
    `;
    }
}
SgdsTable.styles = [...SgdsElement.styles, css_248z];
__decorate([
    property({ type: String, reflect: true })
], SgdsTable.prototype, "responsive", void 0);
__decorate([
    property({ type: Array })
], SgdsTable.prototype, "rowHeader", void 0);
__decorate([
    property({ type: Array })
], SgdsTable.prototype, "columnHeader", void 0);
__decorate([
    property({ type: Array })
], SgdsTable.prototype, "tableData", void 0);
__decorate([
    property({ type: String, reflect: true })
], SgdsTable.prototype, "headerPosition", void 0);
__decorate([
    state()
], SgdsTable.prototype, "originalTableData", void 0);

export { SgdsTable, SgdsTable as default };
//# sourceMappingURL=sgds-table.js.map

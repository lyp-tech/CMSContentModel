import FormControlElement from "../../base/form-control-element";
declare const SgdsRadioGroup_base: (new (...args: any[]) => import("../../utils/validatorMixin").ToBeValidatedElementInterface) & typeof FormControlElement;
/**
 * @summary RadioGroup group multiple radios so they function as a single form control.
 *
 * @slot default - The default slot where sgds-radio are placed.
 * @slot invalidIcon - The slot for invalid icon
 *
 * @event sgds-change - Emitted when the radio group's selected value changes.
 *
 */
export declare class SgdsRadioGroup extends SgdsRadioGroup_base {
    static styles: import("lit").CSSResult[];
    /**@internal */
    defaultSlot: HTMLSlotElement;
    /**@internal */
    defaultValue: string;
    /** The selected value of the control. */
    value: string;
    /**Feedback text for error state when validated */
    invalidFeedback: string;
    /** Allows invalidFeedback, invalid and valid styles to be visible with the input */
    hasFeedback: boolean;
    /** Makes the input as a required field. */
    required: boolean;
    _handleValueChange(): void;
    _handleInvalidChange(): void;
    private _isTouched;
    /**
     * radio requries a custom _mixinResetFormControl as the update of input value
     * requires to fire a reset event manually
     * */
    private _mixinResetFormControl;
    connectedCallback(): void;
    firstUpdated(changedProperties: any): void;
    private _radios;
    private _handleRadioClick;
    /**
     * when input value is set programatically, need to manually dispatch a change event
     * In order to prevent race conditions and ensure sequence of events, set input's value here instead of binding to value prop of input
     */
    private _updateInputValue;
    private _handleKeyDown;
    private _handleSlotChange;
    private _updateCheckedRadio;
    protected _renderHintText(): import("lit-html").TemplateResult<1>;
    /**
     * Checks for validity. Under the hood, HTMLFormElement's reportValidity method calls this method to check for component's validity state
     * Note that the native error popup is prevented for SGDS form components by default. Instead the validation message shows up in the feedback container of SgdsInput
     */
    reportValidity(): boolean;
    /**
     * Checks for validity without any native error popup message
     */
    checkValidity(): boolean;
    /**
     * Returns the ValidityState object
     */
    get validity(): ValidityState;
    /**
     * Returns the validation message based on the ValidityState
     */
    get validationMessage(): string;
    _handleIsTouched(): void;
    _handleDisabledChange(): void;
    private _disabledChildRadios;
    render(): import("lit-html").TemplateResult<1>;
}
export default SgdsRadioGroup;

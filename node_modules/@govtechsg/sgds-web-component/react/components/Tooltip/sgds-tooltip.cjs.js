'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var Tooltip = require('bootstrap/js/src/tooltip');
var lit = require('lit');
var decorators_js = require('lit/decorators.js');
var ref_js = require('lit/directives/ref.js');
var sgdsElement = require('../../base/sgds-element.cjs.js');
var tooltip = require('./tooltip.cjs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Tooltip__default = /*#__PURE__*/_interopDefaultLegacy(Tooltip);

/**
 * @summary Tooltips display more information when users hover over, focus on, or interact with an element.
 * @slot default - The element to target the tooltip to.
 *
 */
class SgdsTooltip extends sgdsElement["default"] {
    constructor() {
        super(...arguments);
        this._myTooltip = ref_js.createRef();
        this._bsTooltip = null;
        /** The tooltip's content. Content has to be textual */
        this.content = "";
        /** The placement of tooltip relative to its target */
        this.placement = "top";
        /** The method to invoke the tooltip. `hover focus` is the default value which allows tooltip to be triggered via mouse hover and keyboard focus. Add `tabindex=0 `for HTMLelements that are not tabbable. */
        this.trigger = "hover focus";
    }
    _handleSlotChange() {
        // For a11y purpose
        this._tooltipTargetElements.forEach(el => el.setAttribute("data-sgds-tooltip", this.content));
    }
    _handleClickOutOfElement(e, self) {
        if (!e.composedPath().includes(self)) {
            this.hide();
        }
    }
    connectedCallback() {
        super.connectedCallback();
        if (this.trigger === "click") {
            document.addEventListener("click", (event) => this._handleClickOutOfElement(event, this));
            document.addEventListener("touchstart", (event) => this._handleClickOutOfElement(event, this));
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        document.removeEventListener("click", (event) => this._handleClickOutOfElement(event, this));
        document.removeEventListener("touchstart", (event) => this._handleClickOutOfElement(event, this));
    }
    _initializeTooltip() {
        this.tooltipConfig = {
            popperConfig: (defaultConfig) => {
                this.popperConfig = defaultConfig;
                const defaultModifiers = defaultConfig.modifiers;
                const newModifiers = defaultModifiers.map(mod => {
                    if (mod.name === "flip") {
                        mod.options.fallbackPlacements = [];
                    }
                    return mod;
                });
                this.popperConfig.modifiers = newModifiers;
                return this.popperConfig;
            },
            placement: this.placement,
            trigger: this.trigger,
            title: this.content,
            html: true,
            container: this.shadowRoot.querySelector("div") // tooltip to appear inside the shadow root of sgds-tooltip instead of anywhere in the DOM, so that scoped styles can apply
        };
        this._bsTooltip = new Tooltip__default["default"](this._myTooltip.value, this.tooltipConfig);
    }
    firstUpdated() {
        this._initializeTooltip();
        this._myTooltip.value.addEventListener("show.bs.tooltip", () => {
            this.emit("sgds-show");
        });
        this._myTooltip.value.addEventListener("shown.bs.tooltip", () => {
            this.emit("sgds-after-show");
        });
        this._myTooltip.value.addEventListener("hide.bs.tooltip", () => {
            this.emit("sgds-hide");
        });
        this._myTooltip.value.addEventListener("hidden.bs.tooltip", () => {
            this.emit("sgds-after-hide");
        });
    }
    /** Hides the Tooltip */
    hide() {
        this._bsTooltip.hide();
    }
    /** Shows the Tooltip */
    show() {
        this._bsTooltip.show();
    }
    render() {
        return lit.html `
      <div ${ref_js.ref(this._myTooltip)} class="tooltip-placeholder">
        <slot @slotchange=${this._handleSlotChange}></slot>
      </div>
    `;
    }
}
SgdsTooltip.styles = [...sgdsElement["default"].styles, tooltip["default"]];
tslib.__decorate([
    decorators_js.property({ type: String })
], SgdsTooltip.prototype, "content", void 0);
tslib.__decorate([
    decorators_js.property({ type: String })
], SgdsTooltip.prototype, "placement", void 0);
tslib.__decorate([
    decorators_js.property({ type: String })
], SgdsTooltip.prototype, "trigger", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsTooltip.prototype, "popperConfig", void 0);
tslib.__decorate([
    decorators_js.queryAssignedElements()
], SgdsTooltip.prototype, "_tooltipTargetElements", void 0);

exports.SgdsTooltip = SgdsTooltip;
exports["default"] = SgdsTooltip;
//# sourceMappingURL=sgds-tooltip.cjs.js.map

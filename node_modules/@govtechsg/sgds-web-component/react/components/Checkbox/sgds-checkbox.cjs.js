'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var lit = require('lit');
var decorators_js = require('lit/decorators.js');
var classMap_js = require('lit/directives/class-map.js');
var ifDefined_js = require('lit/directives/if-defined.js');
var live_js = require('lit/directives/live.js');
var formControlElement = require('../../base/form-control-element.cjs.js');
var defaultvalue = require('../../utils/defaultvalue.cjs.js');
var validatorMixin = require('../../utils/validatorMixin.cjs.js');
var watch = require('../../utils/watch.cjs.js');
var checkbox = require('./checkbox.cjs.js');

/**
 * @summary Checkbox component is used when you require users to select multiple items from a list.
 *
 * @slot default - The label of checkbox.
 *
 * @event sgds-change - Emitted when the checked state changes.
 * @event sgds-blur - Emitted when input is not in focus.
 * @event sgds-focus - Emitted when input is in focus.
 * @event sgds-validity-change - Emitted when the invalid state changes. This event is used by sgds-checkbox-group to check the invalid state change of its children
 */
class SgdsCheckbox extends validatorMixin.SgdsFormValidatorMixin(formControlElement["default"]) {
    constructor() {
        super(...arguments);
        /** Draws the checkbox in a checked state. */
        this.checked = false;
        /** Allows invalidFeedback, invalid and valid styles to be visible with the input */
        this.hasFeedback = false;
        /** Gets or sets the default value used to reset this element. The initial value corresponds to the one originally specified in the HTML that created this element. */
        this.defaultChecked = false;
        /** Marks the checkbox input as indeterminate , with indeterminate logo  */
        this.indeterminate = false;
        /** Makes the checkbox a required field. */
        this.required = false;
        this._isTouched = false;
    }
    _handleInvalidChange() {
        this.emit("sgds-validity-change", {
            detail: { invalid: this.invalid, validationMessage: this.input.validationMessage }
        });
    }
    /** Simulates a click on the checkbox. */
    click() {
        this.input.click();
    }
    /** Sets focus on the checkbox. */
    focus(options) {
        this.input.focus(options);
    }
    /** Removes focus from the checkbox. */
    blur() {
        this.input.blur();
    }
    _handleChange(e) {
        if (this.indeterminate) {
            this.indeterminate = !this.indeterminate;
        }
        this.checked = !this.checked;
        this.value = this.input.value;
        super._mixinHandleChange(e);
        this.emit("sgds-change", { detail: { checked: this.checked, value: this.value } });
    }
    _handleKeyDown(event) {
        const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
        if (event.key === "Enter" && !hasModifier) {
            this.click();
        }
    }
    _handleBlur() {
        this._isTouched = true;
        this.emit("sgds-blur");
    }
    _handleFocus() {
        this.emit("sgds-focus");
    }
    _handleInvalid(e) {
        e.preventDefault();
        this.invalid = true;
    }
    /** @internal */
    _handleDisabledChange() {
        // Disabled form controls are always valid, so we need to recheck validity when the state changes
        this.setInvalid(false);
    }
    _handleIsTouched() {
        if (this._isTouched) {
            this.invalid = !this.input.checkValidity();
        }
    }
    _mixinResetFormControl() {
        this._isTouched = false;
        this.checked = this.input.checked = this.defaultChecked;
        this.input.dispatchEvent(new InputEvent("reset"));
        this._mixinResetValidity(this.input);
    }
    /**
     * Checks for validity. Under the hood, HTMLFormElement's reportValidity method calls this method to check for component's validity state
     * Note that the native error popup is prevented for SGDS form components by default. Instead the validation message shows up in the feedback container of SgdsInput
     */
    reportValidity() {
        return this._mixinReportValidity();
    }
    /**
     * Checks for validity without any native error popup message
     */
    checkValidity() {
        return this._mixinCheckValidity();
    }
    /**
     * Returns the ValidityState object
     */
    get validity() {
        return this._mixinGetValidity();
    }
    /**
     * Returns the validation message based on the ValidityState
     */
    get validationMessage() {
        return this._mixinGetValidationMessage();
    }
    render() {
        return lit.html `
      <div class="form-check">
        <div class="form-check-input-container">
          <input
            class=${classMap_js.classMap({
            "form-check-input": true,
            "is-invalid": this.hasFeedback && this.invalid
        })}
            type="checkbox"
            id=${this._controlId}
            aria-invalid=${this.invalid ? "true" : "false"}
            name=${ifDefined_js.ifDefined(this.name)}
            ?indeterminate=${this.indeterminate}
            ?required=${this.required}
            aria-disabled=${this.disabled ? "true" : "false"}
            aria-checked=${this.checked ? "true" : "false"}
            @change=${(e) => this._handleChange(e)}
            @keydown=${this._handleKeyDown}
            @invalid=${(e) => this._handleInvalid(e)}
            .checked=${live_js.live(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            @blur=${this._handleBlur}
            @focus=${this._handleFocus}
          />
        </div>
        <label for="${this._controlId}" class="form-check-label" id="${this._labelId}"><slot></slot></label>
      </div>
    `;
    }
}
SgdsCheckbox.styles = [...formControlElement["default"].styles, checkbox["default"]];
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsCheckbox.prototype, "value", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "checked", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "hasFeedback", void 0);
tslib.__decorate([
    defaultvalue.defaultValue("checked")
], SgdsCheckbox.prototype, "defaultChecked", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "indeterminate", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsCheckbox.prototype, "required", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsCheckbox.prototype, "_isTouched", void 0);
tslib.__decorate([
    watch.watch("invalid", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleInvalidChange", null);
tslib.__decorate([
    watch.watch("disabled", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleDisabledChange", null);
tslib.__decorate([
    watch.watch("_isTouched", { waitUntilFirstUpdate: true })
], SgdsCheckbox.prototype, "_handleIsTouched", null);

exports.SgdsCheckbox = SgdsCheckbox;
exports["default"] = SgdsCheckbox;
//# sourceMappingURL=sgds-checkbox.cjs.js.map

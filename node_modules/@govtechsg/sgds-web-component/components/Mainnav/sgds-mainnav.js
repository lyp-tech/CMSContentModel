import { __decorate } from 'tslib';
import { html } from 'lit';
import { provide } from '@lit/context';
import { state, query, property, queryAssignedElements } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import SgdsElement from '../../base/sgds-element.js';
import { stopAnimations, animateTo, shimKeyframesHeightAuto } from '../../utils/animate.js';
import { setDefaultAnimation, getAnimation } from '../../utils/animation-registry.js';
import { SM_BREAKPOINT, MD_BREAKPOINT, LG_BREAKPOINT, XL_BREAKPOINT, XXL_BREAKPOINT } from '../../utils/breakpoints.js';
import { waitForEvent } from '../../utils/event.js';
import genId from '../../utils/generateId.js';
import { watch } from '../../utils/watch.js';
import css_248z from './mainnav.js';
import { SgdsIcon } from '../Icon/sgds-icon.js';
import { MainnavContext } from './mainnav-context.js';

const SIZES = {
    sm: SM_BREAKPOINT,
    md: MD_BREAKPOINT,
    lg: LG_BREAKPOINT,
    xl: XL_BREAKPOINT,
    XXL: XXL_BREAKPOINT,
    never: Infinity,
    always: -1
};
/**
 * @summary This component is the primary means that your users will use to navigate through your portal. It includes horizontal navigation and branding to identify your site.
 *
 * @event sgds-show - Emitted on show. Only for collapsed menu.
 * @event sgds-after-show - Emitted on show after animation has completed. Only for collapsed menu.
 * @event sgds-hide - Emitted on hide. Only for collapsed menu.
 * @event sgds-after-hide - Emitted on hide after animation has completed. Only for collapsed menu.
 *
 * @slot default - Default slot of SgdsMainnav. Pass in SgdsMainnavItem elements here.
 * @slot end - Elements in this slot will be positioned to the right end of .navbar-nav. Elements in this slot will also be included in collapsed menu.
 * @slot brand - Brand slot of SgdsMainnav. Pass in brand logo img here
 * @slot non-collapsible - Elements in this slot will not be collapsed
 *
 */
class SgdsMainnav extends SgdsElement {
    constructor() {
        super();
        this._breakpointReached = false;
        /** The href link for brand logo */
        this.brandHref = "";
        this.collapseId = genId("mainnav", "collapse");
        /** The breakpoint, below which, the Navbar will collapse. When always the Navbar will always be expanded regardless of screen size. When never, the Navbar will always be collapsed */
        this.expand = "lg";
        /** @internal */
        this.breakpointReached = false;
        /** @internal */
        this.expanded = false;
        window.addEventListener("resize", () => {
            const newBreakpointReachedValue = window.innerWidth < SIZES[this.expand];
            if (newBreakpointReachedValue !== this.breakpointReached) {
                this.requestUpdate();
            }
            else {
                this.body ? (this.body.hidden = true) : null;
                this.expanded = false;
            }
            if (newBreakpointReachedValue) {
                this._handleMobileNav();
                if (!this._breakpointReached) {
                    this._breakpointReached = true;
                }
            }
            else {
                this._handleDesktopNav();
                this._breakpointReached = false;
            }
        });
    }
    /** @internal */
    get defaultSlotItems() {
        return [...(this.defaultNodes || [])].filter((node) => typeof node.tagName !== "undefined");
    }
    /** @internal */
    get endSlotItems() {
        return [...(this.endNodes || [])].filter((node) => typeof node.tagName !== "undefined");
    }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener("click", (event) => this._handleClickOutOfElement(event, this.body));
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener("click", (event) => this._handleClickOutOfElement(event, this.body));
    }
    firstUpdated() {
        if (this.breakpointReached && this.body) {
            this.expanded = false;
            this.body.hidden = true;
            this._handleMobileNav();
            this._breakpointReached = true;
        }
        const items = [...this.defaultSlotItems, ...this.endSlotItems];
        items.forEach((item) => {
            item.setAttribute("expand", this.expand);
        });
    }
    _handleClickOutOfElement(e, self) {
        if (!e.composedPath().includes(self) && !e.composedPath().includes(this.header)) {
            this.hide();
        }
    }
    _handleSummaryClick() {
        if (this.expanded) {
            this.hide();
        }
        else {
            document.querySelector("body").style.overflow = "hidden";
            this.show();
        }
        this.header.focus();
    }
    async _handleMobileNav() {
        if (!this.nav)
            return;
        this.nav.appendChild(this.body);
        await customElements.whenDefined("sgds-masthead");
        const offsetTop = this.nav.offsetTop;
        const navHeight = this.nav.clientHeight;
        const mainNavPosition = offsetTop + navHeight;
        this.body.style.top = `${mainNavPosition}px`;
        this.navScroll.style.maxHeight = `calc(100dvh - ${mainNavPosition}px)`;
    }
    _handleDesktopNav() {
        var _a;
        (_a = this.navbar) === null || _a === void 0 ? void 0 : _a.insertBefore(this.body, this.nonCollapsibleSlot);
    }
    async _animateToShow() {
        const sgdsShow = this.emit("sgds-show", { cancelable: true });
        if (sgdsShow.defaultPrevented) {
            this.expanded = false;
            return;
        }
        await stopAnimations(this.body);
        this.body.hidden = false;
        const { keyframes, options } = getAnimation(this, "mainnav.show");
        await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
        this.body.style.height = "auto";
        this.emit("sgds-after-show");
    }
    async _animateToHide() {
        const slHide = this.emit("sgds-hide", { cancelable: true });
        if (slHide.defaultPrevented) {
            this.expanded = true;
            return;
        }
        await stopAnimations(this.body);
        const { keyframes, options } = getAnimation(this, "mainnav.hide");
        await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
        this.body.hidden = true;
        this.body.style.height = "auto";
        this.emit("sgds-after-hide");
    }
    async handleOpenChange() {
        if (this.expanded) {
            // Show
            this._animateToShow();
        }
        else {
            // Hide
            this._animateToHide();
        }
    }
    /** Shows the menu. For when mainnav is in the collapsed form */
    async show() {
        if (this.expanded) {
            return;
        }
        this.expanded = true;
        return waitForEvent(this, "sgds-after-show");
    }
    /** Hide the menu. For when mainnav is in the collapsed form */
    async hide() {
        if (!this.expanded) {
            return;
        }
        this.expanded = false;
        document.querySelector("body").style.removeProperty("overflow");
        this.emit("close-dropdown-menu");
        return waitForEvent(this, "sgds-after-hide");
    }
    // assigning name attribute to elements added in slot="end", to use wildcard css selector to assign styles only to *-mainnav-item
    _handleSlotChange(e) {
        const childElements = e.target.assignedElements({ flatten: true });
        childElements.forEach(e => {
            e.setAttribute("name", e.tagName.toLowerCase());
        });
    }
    render() {
        this.breakpointReached = window.innerWidth < SIZES[this.expand];
        return html `
      <nav>
        <div class="navbar ${this._expandClass()}">
          <a class="navbar-brand" href=${this.brandHref} aria-label="brand-link">
            <slot name="brand"></slot>
          </a>
          <div class="navbar-body navbar-collapse" id=${this.collapseId}>
            <div class="navbar-nav navbar-nav-scroll">
              <slot></slot>
              <slot
                name="end"
                class=${classMap({ "slot-end": !this.breakpointReached })}
                @slotchange=${this._handleSlotChange}
              ></slot>
            </div>
          </div>
          <slot name="non-collapsible"></slot>
          <sgds-icon-button
            name=${this.expanded ? "cross" : "menu"}
            variant="ghost"
            size="sm"
            class="navbar-toggler"
            @click=${this._handleSummaryClick}
            aria-controls="${this.collapseId}"
            aria-expanded="${this.expanded}"
            aria-label="Toggle navigation"
          ></sgds-icon-button>
        </div>
      </nav>
    `;
    }
    _expandClass() {
        switch (this.expand) {
            case "always":
                return "navbar-expand";
            case "never":
                break;
            default:
                return `navbar-expand-${this.expand}`;
        }
    }
}
SgdsMainnav.styles = [...SgdsElement.styles, css_248z];
/** @internal */
SgdsMainnav.dependencies = {
    "sgds-icon": SgdsIcon
};
__decorate([
    provide({ context: MainnavContext }),
    state()
], SgdsMainnav.prototype, "_breakpointReached", void 0);
__decorate([
    query("nav")
], SgdsMainnav.prototype, "nav", void 0);
__decorate([
    query(".navbar")
], SgdsMainnav.prototype, "navbar", void 0);
__decorate([
    query(".navbar-toggler")
], SgdsMainnav.prototype, "header", void 0);
__decorate([
    query(".navbar-body")
], SgdsMainnav.prototype, "body", void 0);
__decorate([
    query(".navbar-nav-scroll")
], SgdsMainnav.prototype, "navScroll", void 0);
__decorate([
    query("slot[name='non-collapsible']")
], SgdsMainnav.prototype, "nonCollapsibleSlot", void 0);
__decorate([
    property({ type: String })
], SgdsMainnav.prototype, "brandHref", void 0);
__decorate([
    property({ type: String })
], SgdsMainnav.prototype, "expand", void 0);
__decorate([
    state()
], SgdsMainnav.prototype, "breakpointReached", void 0);
__decorate([
    state()
], SgdsMainnav.prototype, "expanded", void 0);
__decorate([
    queryAssignedElements()
], SgdsMainnav.prototype, "defaultNodes", void 0);
__decorate([
    queryAssignedElements({ slot: "end" })
], SgdsMainnav.prototype, "endNodes", void 0);
__decorate([
    watch("expanded", { waitUntilFirstUpdate: true })
], SgdsMainnav.prototype, "handleOpenChange", null);
setDefaultAnimation("mainnav.show", {
    keyframes: [
        { height: "0", opacity: "0" },
        { height: "auto", opacity: "1" }
    ],
    options: { duration: 200, easing: "ease-in-out" }
});
setDefaultAnimation("mainnav.hide", {
    keyframes: [
        { height: "auto", opacity: "1" },
        { height: "0", opacity: "0" }
    ],
    options: { duration: 200, easing: "ease-in-out" }
});

export { SgdsMainnav, SgdsMainnav as default };
//# sourceMappingURL=sgds-mainnav.js.map

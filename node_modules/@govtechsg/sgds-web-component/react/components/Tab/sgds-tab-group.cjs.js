'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var lit = require('lit');
var decorators_js = require('lit/decorators.js');
var sgdsElement = require('../../base/sgds-element.cjs.js');
var tabGroup = require('./tab-group.cjs.js');

/**
 * @summary Tab Group organizes content into a container with the syncing of tab and their corresponding panels.
 * Each tab must be slotted into the nav slot and its `panel` must refer to a tab panel of the same name.
 *
 * @slot default - The slot for `sgds-tab-panel`
 * @slot nav - The slot for `sgds-tab`
 *
 * @event sgds-tab-show  Emitted when a tab and its panels are shown
 * @event sgds-tab-hide  Emitted when a tab and its panels are hidden.
 *
 */
class SgdsTabGroup extends sgdsElement["default"] {
    constructor() {
        super(...arguments);
        this._tabs = [];
        this._panels = [];
        /** The variant of tabs. Controls the visual styles of all `sgds-tabs` in its slot. It also sets the variant atttribute of `sgds-tab` */
        this.variant = "underlined";
        /** The orientation of tabs. Controls the orientation of all `sgds-tabs` in its slot. It also sets the orientation attribute of `sgds-tab` */
        this.orientation = "horizontal";
        /** The density of tabs. Controls the density of all `sgds-tabs` in its slot. It also sets the density attribute of `sgds-tab` */
        this.density = "default";
    }
    connectedCallback() {
        const whenAllDefined = Promise.all([
            customElements.whenDefined("sgds-tab"),
            customElements.whenDefined("sgds-tab-panel")
        ]);
        super.connectedCallback();
        this._resizeObserver = new ResizeObserver(() => {
            return;
        });
        this._mutationObserver = new MutationObserver(mutations => {
            // Update aria labels when the DOM changes
            if (mutations.some(m => !["aria-labelledby", "aria-controls"].includes(m.attributeName))) {
                setTimeout(() => this._setAriaLabels());
            }
            // Sync tabs when disabled states change
            if (mutations.some(m => m.attributeName === "disabled")) {
                this._syncTabsAndPanels();
            }
        });
        this.updateComplete.then(() => {
            this._syncTabsAndPanels();
            this._mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
            this._resizeObserver.observe(this._nav);
            whenAllDefined.then(() => {
                // Set initial tab state when the tabs first become visible
                const intersectionObserver = new IntersectionObserver((entries, observer) => {
                    var _a;
                    if (entries[0].intersectionRatio > 0) {
                        this._setAriaLabels();
                        // this.setTabVariant();
                        this._setActiveTab((_a = this._getActiveTab()) !== null && _a !== void 0 ? _a : this._tabs[0], { emitEvents: false });
                        observer.unobserve(entries[0].target);
                    }
                });
                intersectionObserver.observe(this._tabGroup);
            });
        });
    }
    disconnectedCallback() {
        this._mutationObserver.disconnect();
        this._resizeObserver.unobserve(this._nav);
    }
    /** Shows the specified tab panel. */
    show(panel) {
        const tab = this._tabs.find(el => el.panel === panel);
        if (tab) {
            this._setActiveTab(tab);
        }
    }
    _getAllTabs(options = { includeDisabled: true }) {
        const slot = this.shadowRoot.querySelector('slot[name="nav"]');
        return [...slot.assignedElements()].filter(el => {
            return options.includeDisabled
                ? el.tagName.toLowerCase() === "sgds-tab"
                : el.tagName.toLowerCase() === "sgds-tab" && !el.disabled;
        });
    }
    _getAllPanels() {
        return [...this._body.assignedElements()].filter(el => el.tagName.toLowerCase() === "sgds-tab-panel");
    }
    _getActiveTab() {
        return this._tabs.find(el => el.active);
    }
    _handleClick(event) {
        const target = event.target;
        const tab = target.closest("sgds-tab");
        const tabGroup = tab === null || tab === void 0 ? void 0 : tab.closest("sgds-tab-group");
        // Ensure the target tab is in this tab group
        if (tabGroup !== this) {
            return;
        }
        if (tab !== null) {
            this._setActiveTab(tab);
        }
    }
    _handleKeyDown(event) {
        const target = event.target;
        const tab = target.closest("sgds-tab");
        const tabGroup = tab === null || tab === void 0 ? void 0 : tab.closest("sgds-tab-group");
        // Ensure the target tab is in this tab group
        if (tabGroup !== this) {
            return;
        }
        // Activate a tab
        if (["Enter", " "].includes(event.key)) {
            if (tab !== null) {
                this._setActiveTab(tab);
                event.preventDefault();
            }
        }
        // Move focus left or right
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
            const activeEl = this._tabs.find(t => t.matches(":focus"));
            if ((activeEl === null || activeEl === void 0 ? void 0 : activeEl.tagName.toLowerCase()) === "sgds-tab") {
                let index = this._tabs.indexOf(activeEl);
                if (event.key === "Home") {
                    index = 0;
                }
                else if (event.key === "End") {
                    index = this._tabs.length - 1;
                }
                else if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
                    index--;
                }
                else if (event.key === "ArrowDown" || event.key === "ArrowRight") {
                    index++;
                }
                if (index < 0) {
                    index = this._tabs.length - 1;
                }
                if (index > this._tabs.length - 1) {
                    index = 0;
                }
                this._tabs[index].focus({ preventScroll: true });
                this._setActiveTab(this._tabs[index] /** , { scrollBehavior: "smooth" }*/);
                event.preventDefault();
            }
        }
    }
    _setActiveTab(tab, options) {
        options = Object.assign({ emitEvents: true }, options);
        if (tab !== this._activeTab && !tab.disabled) {
            const previousTab = this._activeTab;
            this._activeTab = tab;
            // Sync active tab and panel
            this._tabs.forEach(el => {
                el.active = el === this._activeTab ? true : false;
            });
            this._panels.map(el => { var _a; return (el.active = el.name === ((_a = this._activeTab) === null || _a === void 0 ? void 0 : _a.panel)); });
            // Emit events
            if (options.emitEvents) {
                if (previousTab) {
                    this.emit("sgds-tab-hide", { detail: { name: previousTab.panel } });
                }
                this.emit("sgds-tab-show", { detail: { name: this._activeTab.panel } });
            }
        }
    }
    _setAriaLabels() {
        // Link each tab with its corresponding panel
        this._tabs.forEach(tab => {
            const panel = this._panels.find(el => el.name === tab.panel);
            if (panel) {
                tab.setAttribute("aria-controls", panel.getAttribute("id"));
                panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
            }
        });
    }
    // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
    _syncTabsAndPanels() {
        this._tabs = this._getAllTabs({ includeDisabled: false });
        this._panels = this._getAllPanels();
    }
    _updateTabsAttribute(name) {
        if (!this._navSlot)
            return;
        const tabs = this._navSlot;
        tabs.forEach(tab => {
            tab.setAttribute(name, this[name]);
        });
    }
    _handleSlotChange() {
        this._updateTabsAttribute("variant");
        this._updateTabsAttribute("orientation");
        this._updateTabsAttribute("density");
        this._syncTabsAndPanels();
    }
    willUpdate(_changedProperties) {
        // similar to @watch
        if (_changedProperties.has("variant")) {
            this._updateTabsAttribute("variant");
        }
        if (_changedProperties.has("orientation")) {
            this._updateTabsAttribute("orientation");
        }
        if (_changedProperties.has("density")) {
            this._updateTabsAttribute("density");
        }
    }
    render() {
        return lit.html `
      <div class="tab-group" @click=${this._handleClick} @keydown=${this._handleKeyDown}>
        <div class="tab-group__nav" role="tablist">
          <slot name="nav" @slotchange=${this._handleSlotChange}></slot>
        </div>
        <div class="tab-group__content">
          <slot class="tab-group__body" @slotchange=${this._syncTabsAndPanels}></slot>
        </div>
      </div>
    `;
    }
}
SgdsTabGroup.styles = [...sgdsElement["default"].styles, tabGroup["default"]];
tslib.__decorate([
    decorators_js.query(".tab-group")
], SgdsTabGroup.prototype, "_tabGroup", void 0);
tslib.__decorate([
    decorators_js.query(".tab-group__body")
], SgdsTabGroup.prototype, "_body", void 0);
tslib.__decorate([
    decorators_js.query(".tab-group__nav")
], SgdsTabGroup.prototype, "_nav", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsTabGroup.prototype, "variant", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsTabGroup.prototype, "orientation", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsTabGroup.prototype, "density", void 0);
tslib.__decorate([
    decorators_js.queryAssignedElements({ slot: "nav", flatten: true })
], SgdsTabGroup.prototype, "_navSlot", void 0);

exports.SgdsTabGroup = SgdsTabGroup;
exports["default"] = SgdsTabGroup;
//# sourceMappingURL=sgds-tab-group.cjs.js.map

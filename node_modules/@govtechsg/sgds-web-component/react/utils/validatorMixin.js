'use client';
import { __decorate } from 'tslib';
import { queryAsync } from 'lit/decorators.js';
import { InputValidationController } from './inputValidationController.js';

/**
 * @summary The FormValidationMixin used by the form components
 * @param superClass
 * @returns
 */
const SgdsFormValidatorMixin = (superClass) => {
    class ToBeValidatedElement extends superClass {
        constructor() {
            super(...arguments);
            this._isTouched = false;
        }
        connectedCallback() {
            super.connectedCallback();
            this.inputValidationController = new InputValidationController(this);
        }
        async firstUpdated(changedProperties) {
            super.firstUpdated(changedProperties);
            /* Either input or sgds-input. For example, quantity-toggle uses sgds-input */
            this.input =
                this.shadowRoot.querySelector("input") ||
                    (await this.sgdsInput) ||
                    this.shadowRoot.querySelector("textarea") ||
                    (await this.sgdsDatepickerInput);
            this._mixinValidate(this.input);
        }
        /**
         * Native lifecycle of Form-Associated Custom Element Callbacks
         */
        formResetCallback() {
            if (this._mixinResetFormControl) {
                this._mixinResetFormControl();
            }
            else {
                this.value = this.defaultValue;
                this._mixinResetValidity(this.input);
            }
            this._mixinSetFormValue();
        }
        /**
         *
         * Methods use by classes using this mixin
         */
        /**
         * OnChange of form component
         * 1. Make value of control accessible via FormData
         * 2. Run change handler
         */
        _mixinHandleChange(e) {
            this._mixinSetFormValue();
            this.inputValidationController.handleChange(e);
        }
        /**
         * OnChange of form component
         * 1. Make value of control accessible via FormData
         * 2. Run input handler
         */
        _mixinHandleInputChange(e) {
            this._mixinSetFormValue();
            this.inputValidationController.handleInput(e);
        }
        /**
         * During form resetting,
         * 1. ValidityState is reset
         * 2. invalid reactive prop is updated after the reset
         * 3. Revalidates the ValidityState (but do not update invalid prop)
         * to prepare for the next validity check
         * 4. Reset touched state to false for a pristine form
         */
        _mixinResetValidity(input) {
            this.inputValidationController.resetValidity();
            this.inputValidationController.updateInvalidState();
            this.inputValidationController.validateInput(input);
            this._isTouched ? (this._isTouched = false) : null;
        }
        _mixinValidate(input) {
            this.inputValidationController.validateInput(input);
        }
        _mixinSetFormValue() {
            this.inputValidationController.setFormValue();
        }
        _mixinCheckValidity() {
            return this.inputValidationController.checkValidity();
        }
        _mixinReportValidity() {
            return this.inputValidationController.reportValidity();
        }
        _mixinGetValidity() {
            return this.inputValidationController.validity;
        }
        _mixinGetValidationMessage() {
            return this.inputValidationController.validationMessage;
        }
        _mixinSetValidity(flags, message, anchor) {
            return this.inputValidationController.setValidity(flags, message, anchor);
        }
    }
    ToBeValidatedElement.formAssociated = true;
    __decorate([
        queryAsync("sgds-input")
    ], ToBeValidatedElement.prototype, "sgdsInput", void 0);
    __decorate([
        queryAsync("sgds-datepicker-input")
    ], ToBeValidatedElement.prototype, "sgdsDatepickerInput", void 0);
    return ToBeValidatedElement;
};

export { SgdsFormValidatorMixin };
//# sourceMappingURL=validatorMixin.js.map

'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var lit = require('lit');
var decorators_js = require('lit/decorators.js');
var classMap_js = require('lit/directives/class-map.js');
var ifDefined_js = require('lit/directives/if-defined.js');
var live_js = require('lit/directives/live.js');
var ref_js = require('lit/directives/ref.js');
var dropdownListElement = require('../../base/dropdown-list-element.cjs.js');
var feedback = require('../../styles/feedback.cjs.js');
var formHint = require('../../styles/form-hint.cjs.js');
var defaultvalue = require('../../utils/defaultvalue.cjs.js');
var generateId = require('../../utils/generateId.cjs.js');
var validatorMixin = require('../../utils/validatorMixin.cjs.js');
var watch = require('../../utils/watch.cjs.js');
var sgdsBadge = require('../Badge/sgds-badge.cjs.js');
var dropdownMenu = require('../Dropdown/dropdown-menu.cjs.js');
var sgdsIcon = require('../Icon/sgds-icon.cjs.js');
var comboBoxItem = require('./combo-box-item.cjs.js');
var comboBox = require('./combo-box.cjs.js');

/**
 * @summary ComboBox component is used for users to make one or more selections from a list.
 *
 * @slot icon - slot for form control icon to be displayed on the right of the input box.
 *
 * @event sgds-select - Emitted when the combo box's selected value changes.
 * @event sgds-input -  Emitted when user input is received and its value changes.
 */
class SgdsComboBox extends validatorMixin.SgdsFormValidatorMixin(dropdownListElement.DropdownListElement) {
    constructor() {
        super();
        /** The input's label  */
        this.label = "";
        /** The input's hint text below the label */
        this.hintText = "";
        /** Autofocus the input */
        this.autofocus = false;
        /** Disables the input. */
        this.disabled = false;
        /** Makes the input a required field. */
        this.required = false;
        /** Makes the input readonly. */
        this.readonly = false;
        /**
         * IMPORTANT:
         * We still expose `.value` externally, but this is now the underlying ID or data
         * (e.g. 1, 2, 'abc', ...), not the label that appears in the input box.
         */
        this.value = "";
        this.displayValue = "";
        /** @internal Gets or sets the default value used to reset this element. */
        this.defaultValue = "";
        /** Allows invalidFeedback, invalid and valid styles to be visible with the input */
        this.hasFeedback = false;
        /** Feedback text for error state when validated */
        this.invalidFeedback = "";
        /** Marks the component as invalid. Replace the pseudo :invalid selector. */
        this.invalid = false;
        /** The list of items to display in the dropdown.
         * `interface SgdsComboBoxItemData {
         * label: string;
         * value: string;
         * }`
         */
        this.menuList = [];
        /** If true, renders multiple checkbox selection items. If false, single-select. */
        this.multiSelect = false;
        /** The function used to filter the menu list, given the user's input value. */
        this.filterFunction = (inputValue, item) => {
            return item.label.toLowerCase().startsWith(inputValue.toLowerCase());
        };
        /** @internal Managed filtered menu on the fly with input change*/
        this.filteredMenuList = [];
        /** @internal Managed menu to render depending on the activity. On input change, show filteredMenu, on selections and initial state show full menu list. */
        this._renderedMenu = [];
        /** Track selected items (even for single-select, but it will have at most one). */
        this.selectedItems = [];
        this._isTouched = false;
        this._controlId = generateId["default"]("input");
        this._labelId = generateId["default"]("label");
        /** @internal */
        this.modifierOpt = [
            {
                name: "offset",
                options: {
                    offset: [0, 8]
                }
            }
        ];
    }
    connectedCallback() {
        super.connectedCallback();
        this.addEventListener("blur", async () => {
            this.invalid = !this._mixinReportValidity();
        });
        this.addEventListener("sgds-hide", async () => {
            const sgdsInput = await this._sgdsInput;
            sgdsInput.focus();
            this._renderedMenu = this.menuList;
        });
        /** @internal */
        if (this.readonly) {
            this._handleKeyboardMenuEvent = null;
            this._handleKeyboardMenuItemsEvent = null;
        }
    }
    async firstUpdated() {
        super.firstUpdated();
        this._renderedMenu = this.menuList;
        if (this.value) {
            const valueArray = this.value.split(";");
            const initialSelectedItem = this.menuList.filter(({ value }) => valueArray.includes(value));
            this.selectedItems = [...initialSelectedItem, ...this.selectedItems];
            if (!this.multiSelect) {
                this.displayValue = initialSelectedItem[0].label;
            }
        }
        this.multiSelect ? (this.input = await this._multiSelectInput) : (this.input = await this._sgdsInput);
        this._mixinValidate(this.input);
        if (this.menuIsOpen && !this.readonly) {
            this.showMenu();
        }
    }
    async _handleValueChange() {
        if (this.value) {
            this.emit("sgds-select");
        }
        const sgdsInput = await this._sgdsInput;
        this._mixinSetFormValue();
        if (this.multiSelect) {
            this._mixinValidate(this.input);
        }
        else {
            // this._mixinValidate(sgdsInput.input);
            this._mixinValidate(sgdsInput);
        }
        if (!this._isTouched && this.value === "")
            return;
        this.invalid = !this._mixinReportValidity();
    }
    // Called each time the user types in the <sgds-input>, we set .value and show the menu
    async _handleInputChange(e) {
        this.emit("sgds-input");
        const input = e.target;
        this.displayValue = input.value;
        this.filteredMenuList = this.menuList.filter(item => this.filterFunction(this.displayValue, item));
        // reset menu list when displayValue
        if (this.displayValue === "" && !this.multiSelect) {
            this.selectedItems = [];
            this.value = this.selectedItems.join(";");
        }
        this.invalid = false;
        this.showMenu();
        this.displayValue = e.target.value;
        this._renderedMenu = this.filteredMenuList;
        if (this.displayValue === "") {
            this._renderedMenu = this.menuList;
            await this.updateComplete;
        }
    }
    /**
     * Called whenever an <sgds-combo-box-item> dispatches sgds-select"
     */
    async _handleItemSelected(e) {
        var _a, _b, _c;
        const itemEl = e.target;
        const itemLabel = (_b = (_a = itemEl.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "";
        const itemValueAttr = (_c = itemEl.getAttribute("value")) !== null && _c !== void 0 ? _c : itemLabel;
        const foundItem = this.filteredMenuList.find(i => i.value.toString() === itemValueAttr) || {
            label: itemLabel,
            value: itemValueAttr
        };
        if (this.multiSelect) {
            if (!this.selectedItems.some(i => i.value === foundItem.value)) {
                this.selectedItems = [...this.selectedItems, foundItem];
                setTimeout(() => (this.displayValue = ""));
            }
            this.hideMenu();
            this.value = this.selectedItems.map(i => i.value).join(";");
        }
        else {
            // Single-select
            this.selectedItems = [foundItem];
            this.value = foundItem.value.toString();
            this.displayValue = this.selectedItems[0].label;
            this.hideMenu();
        }
    }
    _handleItemUnselect(e) {
        var _a, _b, _c;
        const itemEl = e.target;
        const itemLabel = (_b = (_a = itemEl.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "";
        const itemValueAttr = (_c = itemEl.getAttribute("value")) !== null && _c !== void 0 ? _c : itemLabel;
        const foundItem = this.filteredMenuList.find(i => i.value.toString() === itemValueAttr) || {
            label: itemLabel,
            value: itemValueAttr
        };
        this.selectedItems = this.selectedItems.filter(i => i.value !== foundItem.value);
        this.value = this.selectedItems.map(i => i.value).join(";");
    }
    async _handleBadgeDismissed(item) {
        this.selectedItems = this.selectedItems.filter(i => i.value !== item.value);
        this.value = this.selectedItems.map(i => i.value).join(";");
    }
    async _handleMultiSelectKeyDown(e) {
        // Only do this in multi-select mode
        if (!this.multiSelect) {
            return;
        }
        if (e.key === "Backspace" && this.multiSelect) {
            if (this.displayValue.trim() === "" && this.selectedItems.length > 0) {
                this.selectedItems = this.selectedItems.slice(0, -1);
                this.value = this.selectedItems.map(i => i.value).join(";");
            }
        }
    }
    async _handleInputBlur(e) {
        e.preventDefault();
        if (this.multiSelect) {
            const displayValueMatchedSelectedItems = this.selectedItems.filter(({ label }) => this.displayValue === label);
            if (displayValueMatchedSelectedItems.length <= 0) {
                this.displayValue = "";
            }
        }
        else {
            // Single select
            if (this.selectedItems.length > 0) {
                this.displayValue = this.selectedItems[0].label;
            }
            else {
                this.displayValue = "";
            }
        }
    }
    /**
     * Checks for validity. Under the hood, HTMLFormElement's reportValidity method calls this method to check for component's validity state
     * Note that the native error popup is prevented for SGDS form components by default. Instead the validation message shows up in the feedback container of SgdsInput
     */
    reportValidity() {
        return this._mixinReportValidity();
    }
    /**
     * Checks for validity without any native error popup message
     */
    checkValidity() {
        return this._mixinCheckValidity();
    }
    /**
     * Returns the ValidityState object
     */
    get validity() {
        return this._mixinGetValidity();
    }
    /**
     * Returns the validation message based on the ValidityState
     */
    get validationMessage() {
        return this._mixinGetValidationMessage();
    }
    _renderFeedback() {
        return this.invalid && this.hasFeedback
            ? lit.html ` <div class="invalid-feedback-container">
          <slot name="invalidIcon">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
              <path
                d="M17.5 10C17.5 14.1421 14.1421 17.5 10 17.5C5.85786 17.5 2.5 14.1421 2.5 10C2.5 5.85786 5.85786 2.5 10 2.5C14.1421 2.5 17.5 5.85786 17.5 10ZM10 6.25C9.49805 6.25 9.10584 6.68339 9.15578 7.18285L9.48461 10.4711C9.51109 10.7359 9.7339 10.9375 10 10.9375C10.2661 10.9375 10.4889 10.7359 10.5154 10.4711L10.8442 7.18285C10.8942 6.68339 10.5019 6.25 10 6.25ZM10.0014 11.875C9.48368 11.875 9.06394 12.2947 9.06394 12.8125C9.06394 13.3303 9.48368 13.75 10.0014 13.75C10.5192 13.75 10.9389 13.3303 10.9389 12.8125C10.9389 12.2947 10.5192 11.875 10.0014 11.875Z"
                fill="currentColor"
              />
            </svg>
          </slot>
          <div id="${this._controlId}-invalid" class="invalid-feedback">
            ${this.invalidFeedback ? this.invalidFeedback : this.validationMessage}
          </div>
        </div>`
            : lit.html `${this._renderHintText()}`;
    }
    _renderHintText() {
        const hintTextTemplate = lit.html ` <div id="${this._controlId}Help" class="form-text">${this.hintText}</div> `;
        return this.hintText && hintTextTemplate;
    }
    /** For form reset  */
    async _mixinResetFormControl() {
        this.value = this.defaultValue;
        if (!this.multiSelect) {
            const initialItem = this.menuList.filter(({ value }) => value === this.value);
            if (initialItem.length <= 0) {
                this.displayValue = "";
            }
            else {
                this.displayValue = initialItem[0].label;
            }
            this._mixinResetValidity(await this._sgdsInput);
        }
        else {
            const valueArray = this.value.split(";");
            const initialItem = this.menuList.filter(({ value }) => valueArray.includes(value));
            this.selectedItems = initialItem;
            this._mixinResetValidity(await this._multiSelectInput);
        }
    }
    _menu() {
        const emptyMenu = lit.html ` <div class="empty-menu">No options</div> `;
        const menu = this._renderedMenu.map(item => {
            let isActive = false;
            if (this.multiSelect) {
                const selectedItemValueArray = this.selectedItems.map(i => i.value);
                isActive = selectedItemValueArray.includes(item.value);
            }
            else {
                isActive = item.value === this.value;
            }
            return lit.html `
        <sgds-combo-box-item
          ?active=${isActive}
          ?checkbox=${this.multiSelect}
          value=${item.value}
          @sgds-select=${this._handleItemSelected}
          @sgds-unselect=${this._handleItemUnselect}
        >
          ${item.label}
        </sgds-combo-box-item>
      `;
        });
        return this._renderedMenu.length === 0 ? emptyMenu : menu;
    }
    _handleClick() {
        if (this.readonly) {
            return null;
        }
        if (!this.menuIsOpen) {
            this.showMenu();
        }
        else {
            this.hideMenu();
        }
    }
    _renderLabel() {
        const labelTemplate = lit.html `
      <label
        for=${this._controlId}
        id=${this._labelId}
        class=${classMap_js.classMap({
            "form-label": true,
            required: this.required
        })}
        >${this.label}</label
      >
    `;
        return this.label && labelTemplate;
    }
    _renderInput() {
        const wantFeedbackStyle = this.hasFeedback;
        return lit.html `
      <div
        ${ref_js.ref(this.myDropdown)}
        class="form-control-group ${classMap_js.classMap({
            disabled: this.disabled,
            readonly: this.readonly,
            "is-invalid": this.invalid && wantFeedbackStyle
        })}"
        @click=${this._handleClick}
      >
        <div class="combobox-input-container">
          ${this.multiSelect
            ? lit.html `
                ${this.selectedItems.map(item => lit.html `<sgds-badge
                      outlined
                      variant="neutral"
                      show
                      dismissible
                      @sgds-hide=${() => this._handleBadgeDismissed(item)}
                      >${item.label}</sgds-badge
                    >`)}
              `
            : lit.nothing}
          <input
            class="form-control"
            type="text"
            id=${this._controlId}
            name=${ifDefined_js.ifDefined(this.name)}
            placeholder=${ifDefined_js.ifDefined(this.placeholder)}
            aria-invalid=${this.invalid ? "true" : "false"}
            ?autofocus=${this.autofocus}
            ?disabled=${this.disabled}
            ?readonly=${this.readonly}
            ?required=${this.required}
            .value=${this.displayValue}
            @input=${this._handleInputChange}
            @blur=${this._handleInputBlur}
            aria-describedby=${ifDefined_js.ifDefined(this.invalid && this.hasFeedback ? `${this._controlId}-invalid` : undefined)}
            aria-labelledby="${this._labelId} ${this._controlId}Help ${this.invalid && this.hasFeedback
            ? `${this._controlId}-invalid`
            : ""}"
          />
        </div>
        <sgds-icon name="chevron-down" size="md"></sgds-icon>
      </div>
    `;
    }
    render() {
        return lit.html `
      <div class="combobox" @keydown=${this._handleMultiSelectKeyDown}>
        ${this._renderLabel()}
        <!-- The input -->
        ${this._renderInput()} ${this._renderFeedback()}
        <ul id=${this.dropdownMenuId} class="dropdown-menu" part="menu" tabindex="-1">
          ${this._menu()}
        </ul>
      </div>
      <!-- Required an input element for constraint validation -->
      ${this.multiSelect
            ? lit.html `<input
            .value=${live_js.live(this.value)}
            id="multi-select-input-tracker"
            class="visually-hidden"
            ?required=${this.required}
          />`
            : lit.nothing}
    `;
    }
}
SgdsComboBox.styles = [...dropdownListElement.DropdownListElement.styles, dropdownMenu["default"], formHint["default"], feedback["default"], comboBox["default"]];
/** @internal */
SgdsComboBox.dependencies = {
    "sgds-combo-box-item": comboBoxItem.ComboBoxItem,
    "sgds-icon": sgdsIcon.SgdsIcon,
    "sgds-badge": sgdsBadge.SgdsBadge
};
tslib.__decorate([
    decorators_js.property({ reflect: true })
], SgdsComboBox.prototype, "label", void 0);
tslib.__decorate([
    decorators_js.property({ reflect: true })
], SgdsComboBox.prototype, "hintText", void 0);
tslib.__decorate([
    decorators_js.property({ reflect: true })
], SgdsComboBox.prototype, "name", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsComboBox.prototype, "placeholder", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "autofocus", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "disabled", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "required", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "readonly", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsComboBox.prototype, "value", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsComboBox.prototype, "displayValue", void 0);
tslib.__decorate([
    defaultvalue.defaultValue()
], SgdsComboBox.prototype, "defaultValue", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "hasFeedback", void 0);
tslib.__decorate([
    decorators_js.property({ type: String, reflect: true })
], SgdsComboBox.prototype, "invalidFeedback", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "invalid", void 0);
tslib.__decorate([
    decorators_js.property({ type: Array })
], SgdsComboBox.prototype, "menuList", void 0);
tslib.__decorate([
    decorators_js.property({ type: Boolean, reflect: true })
], SgdsComboBox.prototype, "multiSelect", void 0);
tslib.__decorate([
    decorators_js.property()
], SgdsComboBox.prototype, "filterFunction", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsComboBox.prototype, "filteredMenuList", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsComboBox.prototype, "_renderedMenu", void 0);
tslib.__decorate([
    decorators_js.state()
], SgdsComboBox.prototype, "selectedItems", void 0);
tslib.__decorate([
    decorators_js.queryAsync("input.form-control")
], SgdsComboBox.prototype, "_sgdsInput", void 0);
tslib.__decorate([
    decorators_js.queryAsync("input#multi-select-input-tracker")
], SgdsComboBox.prototype, "_multiSelectInput", void 0);
tslib.__decorate([
    watch.watch("value", { waitUntilFirstUpdate: true })
], SgdsComboBox.prototype, "_handleValueChange", null);

exports.SgdsComboBox = SgdsComboBox;
exports["default"] = SgdsComboBox;
//# sourceMappingURL=sgds-combo-box.cjs.js.map
